{"version":3,"names":["nameStartChar","nameChar","nameRegexp","regexName","RegExp","getAllMatches","string","regex","matches","match","exec","allmatches","startIndex","lastIndex","length","len","index","push","isName","exports","isExist","v","isEmptyObject","obj","Object","keys","merge","target","a","arrayMode","i","getValue","buildOptions","options","defaultOptions","props","newOptions","undefined","isTagNameInArrayMode","tagName","parentTagName","test","convertToJson","node","jObj","alwaysCreateTextNode","child","util","attrsMap","val","cdataPositionChar","asArray","tagname","textNodeName","tag","hasOwnProperty","result","convertToJson_1","xmlNode","parent","this","addChild","Array","isArray","hexRegex","numRegex","Number","parseInt","window","parseFloat","consider","hex","leadingZeros","decimalPoint","eNotation","toNumber","str","assign","trimmedStr","trim","skipLike","sign","numTrimmedByZeros","trimZeros","num","numStr","search","indexOf","replace","substr","strnum","attributeNamePrefix","attrNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","trimValues","cdataTagName","numParseOptions","tagValueProcessor","attrValueProcessor","attrName","stopNodes","defaultOptions_1","props_1","processTagValue","parseValue","resolveNameSpace","tags","split","prefix","charAt","shouldParse","newval","attrsRegx","buildAttributesMap","attrStr","attrs","attrCollection","getTraversalObj","xmlData","xmlObj","currentNode","textData","ch","closeIndex","findClosingIndex","substring","colonIndex","includes","tagExp","childNode","closingIndexForOpeningTag","data","separatorIndex","shouldBuildAttributesMap","lastIndexOf","attrBoundary","errMsg","closingIndex","Error","getTraversalObj_1","validate","tagFound","reachedRoot","readPI","err","tagStartPos","readCommentAndCDATA","closingTag","validateTagName","msg","getErrorObject","getLineNumberForPosition","readAttributeStr","value","attrStrStart","isValid","validateAttributeString","code","line","tagClosed","otg","pop","openPos","col","afterAmp","validateAmpersand","JSON","stringify","map","t","start","angleBracketsCount","doubleQuote","singleQuote","startChar","validAttrStrRegxp","attrNames","getPositionFromMatch","validateAttrName","validateNumberAmpersand","re","count","message","lineNumber","lines","char","String","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","objStart","arrStart","arrayEnd","charsArr","_e","e_schema","hasValidData","hasData","itemSchema","arr_len","arr_i","r","processValue","key","isAppChar","require$$0","convert2nimn","x2j","convert2nimn_1","convertToJsonString","indentBy","_cToJsonStr","level","stringval","isNaN","convertToJsonString_1","format","supressEmptyNode","Parser","isAttribute","attrPrefixLen","isCDATA","replaceCDATAstr","replaceCDATAarr","processTextOrObjNode","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","prototype","parse","rootNodeName","j2x","Date","attr","arrLen","j","item","Ks","L","object","cdata","join","repeat","name","startsWith","json2xml","x2xmlnode","xmlToNodeobj","givenOptions","validationOption","validator","parseTrueNumberOnly","traversableObj","nodeToJson","convertTonimn","require$$1","require$$2","j2xParser","require$$3","parseToNimn","schema"],"sources":["./node_modules/fast-xml-parser/src/util.js","./node_modules/fast-xml-parser/src/node2json.js","./node_modules/fast-xml-parser/src/xmlNode.js","./node_modules/strnum/strnum.js","./node_modules/fast-xml-parser/src/xmlstr2xmlnode.js","./node_modules/fast-xml-parser/src/validator.js","./node_modules/fast-xml-parser/src/nimndata.js","./node_modules/fast-xml-parser/src/node2json_str.js","./node_modules/fast-xml-parser/src/json2xml.js","./node_modules/fast-xml-parser/src/parser.js"],"sourcesContent":["'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options, defaultOptions, props) {\n  let newOptions = {};\n  if (!options) {\n    return defaultOptions; //if there are not options\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    if (options[props[i]] !== undefined) {\n      newOptions[props[i]] = options[props[i]];\n    } else {\n      newOptions[props[i]] = defaultOptions[props[i]];\n    }\n  }\n  return newOptions;\n};\n\n/**\n * Check if a tag name should be treated as array\n *\n * @param tagName the node tagname\n * @param arrayMode the array mode option\n * @param parentTagName the parent tag name\n * @returns {boolean} true if node should be parsed as array\n */\nexports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {\n  if (arrayMode === false) {\n    return false;\n  } else if (arrayMode instanceof RegExp) {\n    return arrayMode.test(tagName);\n  } else if (typeof arrayMode === 'function') {\n    return !!arrayMode(tagName, parentTagName);\n  }\n\n  return arrayMode === \"strict\";\n}\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n","'use strict';\n\nconst util = require('./util');\n\nconst convertToJson = function(node, options, parentTagName) {\n  const jObj = {};\n\n  // when no child node or attr is present\n  if (!options.alwaysCreateTextNode && (!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  }\n\n  // otherwise create a textnode if node has some text\n  if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName)\n    jObj[options.textNodeName] = asArray ? [node.val] : node.val;\n  }\n\n  util.merge(jObj, node.attrsMap, options.arrayMode);\n\n  const keys = Object.keys(node.child);\n  for (let index = 0; index < keys.length; index++) {\n    const tagName = keys[index];\n    if (node.child[tagName] && node.child[tagName].length > 1) {\n      jObj[tagName] = [];\n      for (let tag in node.child[tagName]) {\n        if (node.child[tagName].hasOwnProperty(tag)) {\n          jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));\n        }\n      }\n    } else {\n      const result = convertToJson(node.child[tagName][0], options, tagName);\n      const asArray = (options.arrayMode === true && typeof result === 'object') || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);\n      jObj[tagName] = asArray ? [result] : result;\n    }\n  }\n\n  //add value\n  return jObj;\n};\n\nexports.convertToJson = convertToJson;\n","'use strict';\n\nmodule.exports = function(tagname, parent, val) {\n  this.tagname = tagname;\n  this.parent = parent;\n  this.child = {}; //child tags\n  this.attrsMap = {}; //attributes map\n  this.val = val; //text only\n  this.addChild = function(child) {\n    if (Array.isArray(this.child[child.tagname])) {\n      //already presents\n      this.child[child.tagname].push(child);\n    } else {\n      this.child[child.tagname] = [child];\n    }\n  };\n};\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n// const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat = window.parseFloat;\n}\n\n  \nconst consider = {\n    hex :  true,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    // const options = Object.assign({}, consider);\n    // if(opt.leadingZeros === false){\n    //     options.leadingZeros = false;\n    // }else if(opt.hex === false){\n    //     options.hex = false;\n    // }\n\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    // if(trimmedStr === \"0.0\") return 0;\n    // else if(trimmedStr === \"+0.0\") return 0;\n    // else if(trimmedStr === \"-0.0\") return -0;\n\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n    // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            const eNotation = match[4] || match[6];\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(eNotation){ //given number has enotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    // const decimalPart = match[5].substr(1);\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n\n                    \n                    // const p = numStr.indexOf(\".\");\n                    // const givenIntPart = numStr.substr(0,p);\n                    // const givenDecPart = numStr.substr(p+1);\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    // if(numTrimmedByZeros === numStr){\n                    //     if(options.leadingZeros) return num;\n                    //     else return str;\n                    // }else return str;\n                    if(numTrimmedByZeros === numStr) return num;\n                    else if(sign+numTrimmedByZeros === numStr) return num;\n                    else return str;\n                }\n\n                if(trimmedStr === numStr) return num;\n                else if(trimmedStr === sign+numStr) return num;\n                // else{\n                //     //number with +/- sign\n                //     trimmedStr.test(/[-+][0-9]);\n\n                // }\n                return str;\n            }\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n            \n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\nmodule.exports = toNumber\n","'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst toNumber = require(\"strnum\");\n\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false, //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true, //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  numParseOptions: {\n    hex: true,\n    leadingZeros: true\n  },\n  tagValueProcessor: function(a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function(a, attrName) {\n    return a;\n  },\n  stopNodes: [],\n  alwaysCreateTextNode: false\n  //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'ignoreNameSpace',\n  'allowBooleanAttributes',\n  'parseNodeValue',\n  'parseAttributeValue',\n  'arrayMode',\n  'trimValues',\n  'cdataTagName',\n  'cdataPositionChar',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'parseTrueNumberOnly',\n  'numParseOptions',\n  'stopNodes',\n  'alwaysCreateTextNode'\n];\nexports.props = props;\n\n/**\n * Trim -> valueProcessor -> parse value\n * @param {string} tagName\n * @param {string} val\n * @param {object} options\n */\nfunction processTagValue(tagName, val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.numParseOptions);\n  }\n\n  return val;\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(\n            matches[i][4],\n            options.parseAttributeValue,\n            options.numParseOptions\n          );\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nconst getTraversalObj = function(xmlData, options) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n  options = buildOptions(options, defaultOptions, props);\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n\n//function match(xmlData){\n  for(let i=0; i< xmlData.length; i++){\n    const ch = xmlData[i];\n    if(ch === '<'){\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        /* if (currentNode.parent) {\n          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);\n        } */\n        if(currentNode){\n          if(currentNode.val){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData , options);\n          }else{\n            currentNode.val = processTagValue(tagName, textData , options);\n          }\n        }\n\n        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n          currentNode.child = []\n          if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}\n          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1)\n        }\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\")\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"-->\", i, \"Comment is not closed.\")\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\")\n        const tagExp = xmlData.substring(i, closeIndex);\n        if(tagExp.indexOf(\"[\") >= 0){\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        }else{\n          i = closeIndex;\n        }\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n        if(textData){\n          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData , options);\n          textData = \"\";\n        }\n\n        if (options.cdataTagName) {\n          //add cdata node\n          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);\n          currentNode.addChild(childNode);\n          //for backtracking\n          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n          //add rest value to parent node\n          if (tagExp) {\n            childNode.val = tagExp;\n          }\n        } else {\n          currentNode.val = (currentNode.val || '') + (tagExp || '');\n        }\n\n        i = closeIndex + 2;\n      }else {//Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i+1)\n        let tagExp = result.data;\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        let shouldBuildAttributesMap = true;\n        if(separatorIndex !== -1){\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);\n          }\n        }\n\n        //save text to parent node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue( currentNode.tagname, textData, options);\n          }\n        }\n\n        if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){//selfClosing tag\n\n          if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          }else{\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n\n          const childNode = new xmlNode(tagName, currentNode, '');\n          if(tagName !== tagExp){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n        }else{//opening tag\n\n          const childNode = new xmlNode( tagName, currentNode );\n          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n            childNode.startIndex=closeIndex;\n          }\n          if(tagName !== tagExp && shouldBuildAttributesMap){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n        textData = \"\";\n        i = closeIndex;\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj;\n}\n\nfunction closingIndexForOpeningTag(data, i){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === '>') {\n        return {\n          data: tagExp,\n          index: index\n        }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n};\n\nconst props = ['allowBooleanAttributes'];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = util.buildOptions(options, defaultOptions, props);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n\n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if (xmlData[i] === ' ' || xmlData[i] === '\\t' || xmlData[i] === '\\n' || xmlData[i] === '\\r') {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","'use strict';\nconst char = function(a) {\n  return String.fromCharCode(a);\n};\n\nconst chars = {\n  nilChar: char(176),\n  missingChar: char(201),\n  nilPremitive: char(175),\n  missingPremitive: char(200),\n\n  emptyChar: char(178),\n  emptyValue: char(177), //empty Premitive\n\n  boundryChar: char(179),\n\n  objStart: char(198),\n  arrStart: char(204),\n  arrayEnd: char(185),\n};\n\nconst charsArr = [\n  chars.nilChar,\n  chars.nilPremitive,\n  chars.missingChar,\n  chars.missingPremitive,\n  chars.boundryChar,\n  chars.emptyChar,\n  chars.emptyValue,\n  chars.arrayEnd,\n  chars.objStart,\n  chars.arrStart,\n];\n\nconst _e = function(node, e_schema, options) {\n  if (typeof e_schema === 'string') {\n    //premitive\n    if (node && node[0] && node[0].val !== undefined) {\n      return getValue(node[0].val, e_schema);\n    } else {\n      return getValue(node, e_schema);\n    }\n  } else {\n    const hasValidData = hasData(node);\n    if (hasValidData === true) {\n      let str = '';\n      if (Array.isArray(e_schema)) {\n        //attributes can't be repeated. hence check in children tags only\n        str += chars.arrStart;\n        const itemSchema = e_schema[0];\n        //const itemSchemaType = itemSchema;\n        const arr_len = node.length;\n\n        if (typeof itemSchema === 'string') {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = getValue(node[arr_i].val, itemSchema);\n            str = processValue(str, r);\n          }\n        } else {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = _e(node[arr_i], itemSchema, options);\n            str = processValue(str, r);\n          }\n        }\n        str += chars.arrayEnd; //indicates that next item is not array item\n      } else {\n        //object\n        str += chars.objStart;\n        const keys = Object.keys(e_schema);\n        if (Array.isArray(node)) {\n          node = node[0];\n        }\n        for (let i in keys) {\n          const key = keys[i];\n          //a property defined in schema can be present either in attrsMap or children tags\n          //options.textNodeName will not present in both maps, take it's value from val\n          //options.attrNodeName will be present in attrsMap\n          let r;\n          if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n            r = _e(node.attrsMap[key], e_schema[key], options);\n          } else if (key === options.textNodeName) {\n            r = _e(node.val, e_schema[key], options);\n          } else {\n            r = _e(node.child[key], e_schema[key], options);\n          }\n          str = processValue(str, r);\n        }\n      }\n      return str;\n    } else {\n      return hasValidData;\n    }\n  }\n};\n\nconst getValue = function(a /*, type*/) {\n  switch (a) {\n    case undefined:\n      return chars.missingPremitive;\n    case null:\n      return chars.nilPremitive;\n    case '':\n      return chars.emptyValue;\n    default:\n      return a;\n  }\n};\n\nconst processValue = function(str, r) {\n  if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n    str += chars.boundryChar;\n  }\n  return str + r;\n};\n\nconst isAppChar = function(ch) {\n  return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n  if (jObj === undefined) {\n    return chars.missingChar;\n  } else if (jObj === null) {\n    return chars.nilChar;\n  } else if (\n    jObj.child &&\n    Object.keys(jObj.child).length === 0 &&\n    (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)\n  ) {\n    return chars.emptyChar;\n  } else {\n    return true;\n  }\n}\n\nconst x2j = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\n\nconst convert2nimn = function(node, e_schema, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n  return _e(node, e_schema, options);\n};\n\nexports.convert2nimn = convert2nimn;\n","'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst x2j = require('./xmlstr2xmlnode');\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n\n  options.indentBy = options.indentBy || '';\n  return _cToJsonStr(node, options, 0);\n};\n\nconst _cToJsonStr = function(node, options, level) {\n  let jObj = '{';\n\n  //traver through all the children\n  const keys = Object.keys(node.child);\n\n  for (let index = 0; index < keys.length; index++) {\n    const tagname = keys[index];\n    if (node.child[tagname] && node.child[tagname].length > 1) {\n      jObj += '\"' + tagname + '\" : [ ';\n      for (let tag in node.child[tagname]) {\n        jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';\n      }\n      jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last\n    } else {\n      jObj += '\"' + tagname + '\" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';\n    }\n  }\n  util.merge(jObj, node.attrsMap);\n  //add attrsMap as new children\n  if (util.isEmptyObject(jObj)) {\n    return util.isExist(node.val) ? node.val : '';\n  } else {\n    if (util.isExist(node.val)) {\n      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n        jObj += '\"' + options.textNodeName + '\" : ' + stringval(node.val);\n      }\n    }\n  }\n  //add value\n  if (jObj[jObj.length - 1] === ',') {\n    jObj = jObj.substr(0, jObj.length - 2);\n  }\n  return jObj + '}';\n};\n\nfunction stringval(v) {\n  if (v === true || v === false || !isNaN(v)) {\n    return v;\n  } else {\n    return '\"' + v + '\"';\n  }\n}\n\nfunction indentate(options, level) {\n  return options.indentBy.repeat(level);\n}\n\nexports.convertToJsonString = convertToJsonString;\n","'use strict';\n//parse Empty Node as self closing node\nconst buildOptions = require('./util').buildOptions;\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  format: false,\n  indentBy: '  ',\n  supressEmptyNode: false,\n  tagValueProcessor: function(a) {\n    return a;\n  },\n  attrValueProcessor: function(a) {\n    return a;\n  },\n};\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'cdataTagName',\n  'cdataPositionChar',\n  'format',\n  'indentBy',\n  'supressEmptyNode',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'rootNodeName', //when array as root\n];\n\nfunction Parser(options) {\n  this.options = buildOptions(options, defaultOptions, props);\n  if (this.options.ignoreAttributes || this.options.attrNodeName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n  if (this.options.cdataTagName) {\n    this.isCDATA = isCDATA;\n  } else {\n    this.isCDATA = function(/*a*/) {\n      return false;\n    };\n  }\n  this.replaceCDATAstr = replaceCDATAstr;\n  this.replaceCDATAarr = replaceCDATAarr;\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n\n  if (this.options.supressEmptyNode) {\n    this.buildTextNode = buildEmptyTextNode;\n    this.buildObjNode = buildEmptyObjNode;\n  } else {\n    this.buildTextNode = buildTextValNode;\n    this.buildObjNode = buildObjectNode;\n  }\n\n  this.buildTextValNode = buildTextValNode;\n  this.buildObjectNode = buildObjectNode;\n}\n\nParser.prototype.parse = function(jObj) {\n  if(Array.isArray(jObj) && this.options.rootNodeName && this.options.rootNodeName.length > 1){\n    jObj = {\n      [this.options.rootNodeName] : jObj\n    }\n  }\n  return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node\n    } else if (jObj[key] === null) {\n      val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += ' ' + attr + '=\"' + this.options.attrValueProcessor('' + jObj[key]) + '\"';\n      } else if (this.isCDATA(key)) {\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAstr('', jObj[key]);\n        }\n      } else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          if (jObj[this.options.cdataTagName]) {\n            //value will added while processing cdata\n          } else {\n            val += this.options.tagValueProcessor('' + jObj[key]);\n          }\n        } else {\n          val += this.buildTextNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      if (this.isCDATA(key)) {\n        val += this.indentate(level);\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAarr('', jObj[key]);\n        }\n      } else {\n        //nested nodes\n        const arrLen = jObj[key].length;\n        for (let j = 0; j < arrLen; j++) {\n          const item = jObj[key][j];\n          if (typeof item === 'undefined') {\n            // supress undefined node\n          } else if (item === null) {\n            val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          } else if (typeof item === 'object') {\n            val += this.processTextOrObjNode(item, key, level)\n          } else {\n            val += this.buildTextNode(item, key, '', level);\n          }\n        }\n      }\n    } else {\n      //nested node\n      if (this.options.attrNodeName && key === this.options.attrNodeName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += ' ' + Ks[j] + '=\"' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '\"';\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextNode(result.val, key, result.attrStr, level);\n  } else {\n    return this.buildObjNode(result.val, key, result.attrStr, level);\n  }\n}\n\nfunction replaceCDATAstr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;\n  } else {\n    return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);\n  }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;\n  } else {\n    for (let v in cdata) {\n      str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');\n    }\n    return str + this.newLine;\n  }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n  if (attrStr && val.indexOf('<') === -1) {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      '>' +\n      val +\n      //+ this.newLine\n      // + this.indentate(level)\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  } else {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      this.tagEndChar +\n      val +\n      //+ this.newLine\n      this.indentate(level) +\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  }\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n    //+ this.newLine\n  }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n  return (\n    this.indentate(level) +\n    '<' +\n    key +\n    attrStr +\n    '>' +\n    this.options.tagValueProcessor(val) +\n    '</' +\n    key +\n    this.tagEndChar\n  );\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildTextValNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n  }\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix)) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nfunction isCDATA(name) {\n  return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;\n","'use strict';\n\nconst nodeToJson = require('./node2json');\nconst xmlToNodeobj = require('./xmlstr2xmlnode');\nconst x2xmlnode = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\nconst validator = require('./validator');\n\nexports.parse = function(xmlData, givenOptions = {}, validationOption) {\n  if( validationOption){\n    if(validationOption === true) validationOption = {}\n    \n    const result = validator.validate(xmlData, validationOption);\n    if (result !== true) {\n      throw Error( result.err.msg)\n    }\n  }\n  if(givenOptions.parseTrueNumberOnly \n    && givenOptions.parseNodeValue !== false\n    && !givenOptions.numParseOptions){\n    \n      givenOptions.numParseOptions = {\n        leadingZeros: false,\n      }\n  }\n  let options = buildOptions(givenOptions, x2xmlnode.defaultOptions, x2xmlnode.props);\n\n  const traversableObj = xmlToNodeobj.getTraversalObj(xmlData, options)\n  //print(traversableObj, \"  \");\n  return nodeToJson.convertToJson(traversableObj, options);\n};\nexports.convertTonimn = require('./nimndata').convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = require('./node2json_str').convertToJsonString;\nexports.validate = validator.validate;\nexports.j2xParser = require('./json2xml');\nexports.parseToNimn = function(xmlData, schema, options) {\n  return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);\n};\n\n\nfunction print(xmlNode, indentation){\n  if(xmlNode){\n    console.log(indentation + \"{\")\n    console.log(indentation + \"  \\\"tagName\\\": \\\"\" + xmlNode.tagname + \"\\\", \");\n    if(xmlNode.parent){\n      console.log(indentation + \"  \\\"parent\\\": \\\"\" + xmlNode.parent.tagname  + \"\\\", \");\n    }\n    console.log(indentation + \"  \\\"val\\\": \\\"\" + xmlNode.val  + \"\\\", \");\n    console.log(indentation + \"  \\\"attrs\\\": \" + JSON.stringify(xmlNode.attrsMap,null,4)  + \", \");\n\n    if(xmlNode.child){\n      console.log(indentation + \"\\\"child\\\": {\")\n      const indentation2 = indentation + indentation;\n      Object.keys(xmlNode.child).forEach( function(key) {\n        const node = xmlNode.child[key];\n\n        if(Array.isArray(node)){\n          console.log(indentation +  \"\\\"\"+key+\"\\\" :[\")\n          node.forEach( function(item,index) {\n            //console.log(indentation + \" \\\"\"+index+\"\\\" : [\")\n            print(item, indentation2);\n          })\n          console.log(indentation + \"],\")  \n        }else{\n          console.log(indentation + \" \\\"\"+key+\"\\\" : {\")\n          print(node, indentation2);\n          console.log(indentation + \"},\")  \n        }\n      });\n      console.log(indentation + \"},\")\n    }\n    console.log(indentation + \"},\")\n  }\n}\n"],"mappings":"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"}